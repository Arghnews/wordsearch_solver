<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wordsearch Solver: compact_trie::CompactTrie Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wordsearch Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecompact__trie.html">compact_trie</a></li><li class="navelem"><a class="el" href="classcompact__trie_1_1CompactTrie.html">CompactTrie</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcompact__trie_1_1CompactTrie-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">compact_trie::CompactTrie Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inline contiguous immutable trie.  
 <a href="classcompact__trie_1_1CompactTrie.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="compact__trie_8hpp_source.html">compact_trie.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a40c194aca22845571bf651b9510954b2"><td class="memItemLeft" align="right" valign="top"><a id="a40c194aca22845571bf651b9510954b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Nodes</b> = std::vector&lt; <a class="el" href="classcompact__trie_1_1Node.html">Node</a> &gt;</td></tr>
<tr class="separator:a40c194aca22845571bf651b9510954b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b90a5d4dc4a88d558873dacf40b819"><td class="memItemLeft" align="right" valign="top"><a id="a11b90a5d4dc4a88d558873dacf40b819"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodesIterator</b> = std::vector&lt; <a class="el" href="classcompact__trie_1_1Node.html">Node</a> &gt;::const_iterator</td></tr>
<tr class="separator:a11b90a5d4dc4a88d558873dacf40b819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ec0ab96406116ea12c7d7475be63f5"><td class="memItemLeft" align="right" valign="top"><a id="a72ec0ab96406116ea12c7d7475be63f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Rows</b> = std::vector&lt; NodesIterator &gt;</td></tr>
<tr class="separator:a72ec0ab96406116ea12c7d7475be63f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fa6013b8e68c1c5719f98a3c9cd86b"><td class="memItemLeft" align="right" valign="top"><a id="a79fa6013b8e68c1c5719f98a3c9cd86b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RowsIterator</b> = Rows::const_iterator</td></tr>
<tr class="separator:a79fa6013b8e68c1c5719f98a3c9cd86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef8146f5cf52e6dfbb301e6197adfd8"><td class="memItemLeft" align="right" valign="top"><a id="a6ef8146f5cf52e6dfbb301e6197adfd8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = std::tuple&lt; NodesIterator, RowsIterator &gt;</td></tr>
<tr class="separator:a6ef8146f5cf52e6dfbb301e6197adfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee1f0db888af407538b83dbde1c8d743"><td class="memItemLeft" align="right" valign="top"><a id="aee1f0db888af407538b83dbde1c8d743"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompactTrie</b> (<a class="el" href="classcompact__trie_1_1CompactTrie.html">CompactTrie</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aee1f0db888af407538b83dbde1c8d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56f42ff958bbe355fececda98e9046e"><td class="memItemLeft" align="right" valign="top"><a id="ae56f42ff958bbe355fececda98e9046e"></a>
<a class="el" href="classcompact__trie_1_1CompactTrie.html">CompactTrie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcompact__trie_1_1CompactTrie.html">CompactTrie</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ae56f42ff958bbe355fececda98e9046e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86d7bf85d5ee99ab42d73628ffa3860"><td class="memItemLeft" align="right" valign="top"><a id="ad86d7bf85d5ee99ab42d73628ffa3860"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompactTrie</b> (const <a class="el" href="classcompact__trie_1_1CompactTrie.html">CompactTrie</a> &amp;)=delete</td></tr>
<tr class="separator:ad86d7bf85d5ee99ab42d73628ffa3860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0782d99d2b8ee51354d4616b2765f146"><td class="memItemLeft" align="right" valign="top"><a id="a0782d99d2b8ee51354d4616b2765f146"></a>
<a class="el" href="classcompact__trie_1_1CompactTrie.html">CompactTrie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcompact__trie_1_1CompactTrie.html">CompactTrie</a> &amp;)=delete</td></tr>
<tr class="separator:a0782d99d2b8ee51354d4616b2765f146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca91cf177131881926f857f6df7902a"><td class="memItemLeft" align="right" valign="top"><a id="a8ca91cf177131881926f857f6df7902a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompactTrie</b> (const std::initializer_list&lt; std::string_view &gt; &amp;words)</td></tr>
<tr class="separator:a8ca91cf177131881926f857f6df7902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209b46213720c93bae174a9f8f000a47"><td class="memItemLeft" align="right" valign="top"><a id="a209b46213720c93bae174a9f8f000a47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompactTrie</b> (const std::initializer_list&lt; std::string &gt; &amp;words)</td></tr>
<tr class="separator:a209b46213720c93bae174a9f8f000a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397b08f2a92c1bb818ca34c779f08242"><td class="memItemLeft" align="right" valign="top"><a id="a397b08f2a92c1bb818ca34c779f08242"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompactTrie</b> (const std::initializer_list&lt; const char * &gt; &amp;words)</td></tr>
<tr class="separator:a397b08f2a92c1bb818ca34c779f08242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9295407dcf6198fba6edb5881286967"><td class="memTemplParams" colspan="2"><a id="ae9295407dcf6198fba6edb5881286967"></a>
template&lt;class Iterator1 , class Iterator2 &gt; </td></tr>
<tr class="memitem:ae9295407dcf6198fba6edb5881286967"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CompactTrie</b> (Iterator1 first, const Iterator2 last)</td></tr>
<tr class="separator:ae9295407dcf6198fba6edb5881286967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1c72290d96fb39cf12fdc5da1f23e7"><td class="memTemplParams" colspan="2"><a id="a2e1c72290d96fb39cf12fdc5da1f23e7"></a>
template&lt;class Strings &gt; </td></tr>
<tr class="memitem:a2e1c72290d96fb39cf12fdc5da1f23e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcompact__trie_1_1CompactTrie.html#a2e1c72290d96fb39cf12fdc5da1f23e7">CompactTrie</a> (Strings &amp;&amp;strings_in)</td></tr>
<tr class="memdesc:a2e1c72290d96fb39cf12fdc5da1f23e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual constructor, all other delegate to this. <br /></td></tr>
<tr class="separator:a2e1c72290d96fb39cf12fdc5da1f23e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2443f1c36dbbfdd8882f5ceb043483bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcompact__trie_1_1CompactTrie.html#a2443f1c36dbbfdd8882f5ceb043483bf">contains</a> (std::string_view word) const</td></tr>
<tr class="memdesc:a2443f1c36dbbfdd8882f5ceb043483bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this dictionary contains <code>word</code>.  <a href="classcompact__trie_1_1CompactTrie.html#a2443f1c36dbbfdd8882f5ceb043483bf">More...</a><br /></td></tr>
<tr class="separator:a2443f1c36dbbfdd8882f5ceb043483bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f07e85510c1dbfda1c4ddd691e4a9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcompact__trie_1_1CompactTrie.html#ae8f07e85510c1dbfda1c4ddd691e4a9e">further</a> (std::string_view word) const</td></tr>
<tr class="memdesc:ae8f07e85510c1dbfda1c4ddd691e4a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this dictionary <b>might</b> contain words with <code>word</code> as a prefix.  <a href="classcompact__trie_1_1CompactTrie.html#ae8f07e85510c1dbfda1c4ddd691e4a9e">More...</a><br /></td></tr>
<tr class="separator:ae8f07e85510c1dbfda1c4ddd691e4a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae633f315a456e8583e81c951b14f017f"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:ae633f315a456e8583e81c951b14f017f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcompact__trie_1_1CompactTrie.html#ae633f315a456e8583e81c951b14f017f">contains_further</a> (std::string_view stem, std::string_view suffixes, OutputIterator contains_further_it) const</td></tr>
<tr class="memdesc:ae633f315a456e8583e81c951b14f017f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each char in suffix appended to stem, check whether this dictionary contains this word and if it may contain longer words with this prefix.  <a href="classcompact__trie_1_1CompactTrie.html#ae633f315a456e8583e81c951b14f017f">More...</a><br /></td></tr>
<tr class="separator:ae633f315a456e8583e81c951b14f017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b99d7dae8ef68805384948e15308dd"><td class="memItemLeft" align="right" valign="top"><a id="a10b99d7dae8ef68805384948e15308dd"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a10b99d7dae8ef68805384948e15308dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344c37d40d5183c40a663fb700c794f6"><td class="memItemLeft" align="right" valign="top"><a id="a344c37d40d5183c40a663fb700c794f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:a344c37d40d5183c40a663fb700c794f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aee96404b78213a298fe1dca3e3001d2d"><td class="memItemLeft" align="right" valign="top"><a id="aee96404b78213a298fe1dca3e3001d2d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (std::string_view word, ranges::subrange&lt; NodesIterator &gt; nodes, ranges::subrange&lt; RowsIterator &gt; rows) const</td></tr>
<tr class="separator:aee96404b78213a298fe1dca3e3001d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c1742e727ea2a53bbc2c894c5b3d9a"><td class="memItemLeft" align="right" valign="top"><a id="a95c1742e727ea2a53bbc2c894c5b3d9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>further</b> (std::string_view word, ranges::subrange&lt; NodesIterator &gt; nodes, ranges::subrange&lt; RowsIterator &gt; rows) const</td></tr>
<tr class="separator:a95c1742e727ea2a53bbc2c894c5b3d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6166d96f799533b9796dc7bd30bb8d57"><td class="memItemLeft" align="right" valign="top">CompactTrie::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcompact__trie_1_1CompactTrie.html#a6166d96f799533b9796dc7bd30bb8d57">search</a> (std::string_view word, ranges::subrange&lt; CompactTrie::NodesIterator &gt; nodes, ranges::subrange&lt; CompactTrie::RowsIterator &gt; rows) const</td></tr>
<tr class="memdesc:a6166d96f799533b9796dc7bd30bb8d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search as far as possible for <code>word</code>.  <a href="classcompact__trie_1_1CompactTrie.html#a6166d96f799533b9796dc7bd30bb8d57">More...</a><br /></td></tr>
<tr class="separator:a6166d96f799533b9796dc7bd30bb8d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab6b34c5d821762436b1d307b09028833"><td class="memItemLeft" align="right" valign="top"><a id="ab6b34c5d821762436b1d307b09028833"></a>
Nodes&#160;</td><td class="memItemRight" valign="bottom"><b>nodes_</b></td></tr>
<tr class="separator:ab6b34c5d821762436b1d307b09028833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030cd47cbd215a62349e96da4ab4eee1"><td class="memItemLeft" align="right" valign="top"><a id="a030cd47cbd215a62349e96da4ab4eee1"></a>
Rows&#160;</td><td class="memItemRight" valign="bottom"><b>rows_</b></td></tr>
<tr class="separator:a030cd47cbd215a62349e96da4ab4eee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a7fae77102656a26fbfb145526b27e"><td class="memItemLeft" align="right" valign="top"><a id="ac5a7fae77102656a26fbfb145526b27e"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_</b></td></tr>
<tr class="separator:ac5a7fae77102656a26fbfb145526b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a772fb9119e7c596b292f239083d56f7c"><td class="memItemLeft" align="right" valign="top"><a id="a772fb9119e7c596b292f239083d56f7c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classcompact__trie_1_1CompactTrie.html">CompactTrie</a> &amp;ct)</td></tr>
<tr class="separator:a772fb9119e7c596b292f239083d56f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Inline contiguous immutable trie. </p>
<p>Based on the <a class="el" href="classtrie_1_1Trie.html" title="Recursive immutable node based trie.">trie::Trie</a>, but now everything's inline, and the whole thing is in one big contiguous memory block.</p>
<dl class="section note"><dt>Note</dt><dd>This (currently) only works for lowercase ascii, as internally a <code>std::bitset&lt;26&gt;</code> is used to represent child nodes. Also, libstdc++ 8 uses a minimum of one <code>unsigned long</code>, 8 bytes, to represent even this, when 4 bytes would do (potential optimisation rolling own bitset etc?).</dd></dl>
<p>A node consists of a bitset of size 26 (bits), with each bit representing an edge to a child node and a letter. A node also has a bool to indicate whether it's a word end, and an int to indicate how many nodes before this one on the same row existed, which is required for calculating the offset in the next row of the child nodes. We also keep a track of indexes into said vector of nodes that correspond to each row. A row corresponds to all the letters at that position in a word.</p>
<p>Lookup for a word of length "m" is similar to the trie, however now each lookup for every letter of a word, rather than a linear search through a small list of letters, is a lookup for a bit being on in a bitset. O(n) in the number of child nodes or letters from that stem, to O(1), a simple bitmask.</p>
<p>Then, assuming that letter is present, read off from the node the offset on the next row, where that letter's next node is found. Lookup for a word of length m is O(m), plus likely better cache locality (unless change trie to use a different allocator, which should be possible as can precompute size from input, but then you basically end up making this anyway). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2443f1c36dbbfdd8882f5ceb043483bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2443f1c36dbbfdd8882f5ceb043483bf">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool compact_trie::CompactTrie::contains </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this dictionary contains <code>word</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>The word to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>word</code> is present, else <code>false</code> </dd></dl>

</div>
</div>
<a id="ae633f315a456e8583e81c951b14f017f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae633f315a456e8583e81c951b14f017f">&#9670;&nbsp;</a></span>contains_further()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compact_trie::CompactTrie::contains_further </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>stem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>suffixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>contains_further_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each char in suffix appended to stem, check whether this dictionary contains this word and if it may contain longer words with this prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stem</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffixes</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contains_further_it</td><td>This function is what the solver algorithm calls every iteration to ask the dictionary solver implementation to do its work.</td></tr>
  </table>
  </dd>
</dl>
<p><code>contains_further_it</code> should be assigned to and incremented like an output iterator. The value written should be a std::pair&lt;bool, bool&gt;.</p>
<p>Example contains_further implementation: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* node = this-&gt;<a class="code" href="classcompact__trie_1_1CompactTrie.html#a6166d96f799533b9796dc7bd30bb8d57">search</a>(stem);</div>
<div class="line"><span class="keywordflow">if</span> (!node) {</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> [i, c] : ranges::views::enumerate(suffixes)) {</div>
<div class="line">  <span class="keyword">const</span> std::string_view suffix = {&amp;c, 1};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="classcompact__trie_1_1CompactTrie.html#a2443f1c36dbbfdd8882f5ceb043483bf">contains</a> = detail::contains(*node, suffix);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="classcompact__trie_1_1CompactTrie.html#ae8f07e85510c1dbfda1c4ddd691e4a9e">further</a> = detail::further(*node, suffix);</div>
<div class="line">  *contains_further_it++ = {<a class="code" href="classcompact__trie_1_1CompactTrie.html#a2443f1c36dbbfdd8882f5ceb043483bf">contains</a>, <a class="code" href="classcompact__trie_1_1CompactTrie.html#ae8f07e85510c1dbfda1c4ddd691e4a9e">further</a>};</div>
<div class="line">}</div>
<div class="ttc" id="aclasscompact__trie_1_1CompactTrie_html_a2443f1c36dbbfdd8882f5ceb043483bf"><div class="ttname"><a href="classcompact__trie_1_1CompactTrie.html#a2443f1c36dbbfdd8882f5ceb043483bf">compact_trie::CompactTrie::contains</a></div><div class="ttdeci">bool contains(std::string_view word) const</div><div class="ttdoc">Check if this dictionary contains word.</div><div class="ttdef"><b>Definition:</b> compact_trie.cpp:56</div></div>
<div class="ttc" id="aclasscompact__trie_1_1CompactTrie_html_a6166d96f799533b9796dc7bd30bb8d57"><div class="ttname"><a href="classcompact__trie_1_1CompactTrie.html#a6166d96f799533b9796dc7bd30bb8d57">compact_trie::CompactTrie::search</a></div><div class="ttdeci">CompactTrie::const_iterator search(std::string_view word, ranges::subrange&lt; CompactTrie::NodesIterator &gt; nodes, ranges::subrange&lt; CompactTrie::RowsIterator &gt; rows) const</div><div class="ttdoc">Search as far as possible for word.</div><div class="ttdef"><b>Definition:</b> compact_trie.cpp:133</div></div>
<div class="ttc" id="aclasscompact__trie_1_1CompactTrie_html_ae8f07e85510c1dbfda1c4ddd691e4a9e"><div class="ttname"><a href="classcompact__trie_1_1CompactTrie.html#ae8f07e85510c1dbfda1c4ddd691e4a9e">compact_trie::CompactTrie::further</a></div><div class="ttdeci">bool further(std::string_view word) const</div><div class="ttdoc">Check if this dictionary might contain words with word as a prefix.</div><div class="ttdef"><b>Definition:</b> compact_trie.cpp:72</div></div>
</div><!-- fragment --><p>Each character's position in <code>suffix</code> corresponds to the order that that <code>suffix's</code> output should be written to <code>contains_further_it</code>.</p>
<p><code>suffixes</code> is <b>not</b> guaranteed to be sorted. </p>

</div>
</div>
<a id="ae8f07e85510c1dbfda1c4ddd691e4a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f07e85510c1dbfda1c4ddd691e4a9e">&#9670;&nbsp;</a></span>further()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool compact_trie::CompactTrie::further </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this dictionary <b>might</b> contain words with <code>word</code> as a prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>The prefix to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if there are no more strings in the dictionary with <code>word</code> as a prefix, <code>true</code> if there might be.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some solvers do not conclusively know whether, for a prefix <code>word</code>, there are more words that contain that prefix. This is acceptable, though sub-optimal and will result in wasted search time, as long as eventually this returns false, assuming for <code>word</code> there are in fact no more words with that prefix. </dd></dl>

</div>
</div>
<a id="a6166d96f799533b9796dc7bd30bb8d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6166d96f799533b9796dc7bd30bb8d57">&#9670;&nbsp;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompactTrie::const_iterator compact_trie::CompactTrie::search </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ranges::subrange&lt; CompactTrie::NodesIterator &gt;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ranges::subrange&lt; CompactTrie::RowsIterator &gt;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search as far as possible for <code>word</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>Word to find </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>Range of nodes in which to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>Range of rows </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator into <code>nodes</code> and an iterator into <code>rows</code>.</dd></dl>
<p>Search as far as possible for <code>word</code> in <code>nodes</code> given <code>rows</code>.</p>
<p>Returns <code>{it, rows_it}</code>. If <code>word</code> is found, <code>std::distance(rows.begin(), rows_it) == word.size()</code> Else it will the deepest node/letter present in the dictionary, in <code>word</code> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>compact_trie/include/wordsearch_solver/compact_trie/<a class="el" href="compact__trie_8hpp_source.html">compact_trie.hpp</a></li>
<li>compact_trie/include/wordsearch_solver/compact_trie/compact_trie.tpp</li>
<li>compact_trie/src/compact_trie.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
