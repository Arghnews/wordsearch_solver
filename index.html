<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wordsearch Solver: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wordsearch Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Wordsearch Solver Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_DoxygenREADME"></a> Inspired by the struggle for high scores in <a href="http://spelltower.com/">spelltower</a>, this program solves wordsearches.</p>
<p>Example program, as in example/main.cpp</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;wordsearch_solver/wordsearch_solver.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fmt/core.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fmt/format.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fmt/ranges.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;initializer_list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string_view&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="comment">// Define a wordsearch</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;std::string&gt; wordsearch = {</div>
<div class="line">    <span class="stringliteral">&quot;adg&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;beh&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;cfi&quot;</span>,</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Define a container of string-like objects that is the dictionary</span></div>
<div class="line">  <span class="keyword">const</span> std::initializer_list&lt;std::string_view&gt; dictionary = {<span class="stringliteral">&quot;zoo&quot;</span>, <span class="stringliteral">&quot;badge&quot;</span>,</div>
<div class="line">                                                              <span class="stringliteral">&quot;be&quot;</span>, <span class="stringliteral">&quot;beg&quot;</span>};</div>
<div class="line">  <span class="comment">// const auto dictionary = utility::read_file_as_lines(&quot;path/to/dict&quot;);</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespacesolver.html">solver</a> = <a class="code" href="classsolver_1_1SolverDictFactory.html">solver::SolverDictFactory</a>{}.<a class="code" href="classsolver_1_1SolverDictFactory.html#a34a8a9205dc439e75d4621fe5d4629a9">make</a>(<span class="stringliteral">&quot;trie&quot;</span>, dictionary);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> grid = <a class="code" href="namespacesolver.html#a7f7f19d730a14f067462510e0d7c58e1">solver::make_grid</a>(wordsearch);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve the wordsearch</span></div>
<div class="line">  <span class="keyword">const</span> solver::WordToListOfListsOfIndexes answer = <a class="code" href="namespacesolver.html#ac5eb7f14c45f64a37eed4815044c2731">solver::solve</a>(<a class="code" href="namespacesolver.html">solver</a>, grid);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [word, indexes] : answer) {</div>
<div class="line">    fmt::print(<span class="stringliteral">&quot;{}: {}\n&quot;</span>, word, indexes);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// [0, 0] is top left, &#39;a&#39;. [1, 0] is &#39;b&#39;. [2, 1] is &#39;f&#39;.</span></div>
<div class="line">  <span class="comment">// Prints:</span></div>
<div class="line">  <span class="comment">// beg: {{[1, 0], [1, 1], [0, 2]}}</span></div>
<div class="line">  <span class="comment">// be: {{[1, 0], [1, 1]}}</span></div>
<div class="line">  <span class="comment">// badge: {{[1, 0], [0, 0], [0, 1], [0, 2], [1, 1]}}</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasssolver_1_1SolverDictFactory_html"><div class="ttname"><a href="classsolver_1_1SolverDictFactory.html">solver::SolverDictFactory</a></div><div class="ttdoc">This class can be used to check if a particular dictionary solver implementation exists,...</div><div class="ttdef"><b>Definition:</b> solver.hpp:173</div></div>
<div class="ttc" id="aclasssolver_1_1SolverDictFactory_html_a34a8a9205dc439e75d4621fe5d4629a9"><div class="ttname"><a href="classsolver_1_1SolverDictFactory.html#a34a8a9205dc439e75d4621fe5d4629a9">solver::SolverDictFactory::make</a></div><div class="ttdeci">SolverDictWrapper make(const std::string_view solver, Words &amp;&amp;dictionary) const</div><div class="ttdoc">Make a dictionary solver.</div><div class="ttdef"><b>Definition:</b> solver.tpp:330</div></div>
<div class="ttc" id="anamespacesolver_html"><div class="ttname"><a href="namespacesolver.html">solver</a></div><div class="ttdoc">Classes to solve a wordsearch.</div><div class="ttdef"><b>Definition:</b> solver.hpp:25</div></div>
<div class="ttc" id="anamespacesolver_html_a7f7f19d730a14f067462510e0d7c58e1"><div class="ttname"><a href="namespacesolver.html#a7f7f19d730a14f067462510e0d7c58e1">solver::make_grid</a></div><div class="ttdeci">WordsearchGrid make_grid(const std::vector&lt; std::string &gt; &amp;lines)</div><div class="ttdoc">Helper function to construct a WordsearchGrid</div><div class="ttdef"><b>Definition:</b> solver.cpp:17</div></div>
<div class="ttc" id="anamespacesolver_html_ac5eb7f14c45f64a37eed4815044c2731"><div class="ttname"><a href="namespacesolver.html#ac5eb7f14c45f64a37eed4815044c2731">solver::solve</a></div><div class="ttdeci">WordToListOfListsOfIndexes solve(const SolverDict &amp;solver_dict, const WordsearchGrid &amp;grid)</div><div class="ttdoc">Runs solve_index() on every element of grid to solve the whole wordsearch.</div><div class="ttdef"><b>Definition:</b> solver.tpp:297</div></div>
</div><!-- fragment --><p>NOTE: must <code>cd</code> to build/test and run ./the_test from this dir!</p>
<p>NOTE: requires gnu-gold linker to build with gcc, and lld (llvm linker) to build with clang</p>
<p>Built and tested with gcc8, clang 10 and clang 12</p>
<p>Uses:</p><ul>
<li><a href="https://conan.io/">conan</a> - package management</li>
<li><a href="https://cmake.org/">CMake</a> - build system</li>
<li><a href="https://fmt.dev/latest/index.html">fmtlib</a> - string formatting and printing</li>
<li><a href="https://github.com/ericniebler/range-v3">range-v3</a> - composable functional range manipulation</li>
<li><a href="https://www.boost.org/">boost</a> - container, iterator</li>
<li><a href="https://github.com/catchorg/Catch2">catch2</a> - testing</li>
<li><a href="https://github.com/google/benchmark">Google benchmark</a> - simple benchmarking</li>
<li><a href="https://github.com/Arghnews/gperftools">Slightly modified gperftools</a> - profiling</li>
<li><a href="https://github.com/jarro2783/cxxopts">cxxopts</a> - argument parsing</li>
</ul>
<p>NOTE: won't work on Windows because gperftools only supports linux. However this is only used for profiling purposes. Without this, it <em>should</em> work, although may need tweaking, untested.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
How to build</h2>
<p>The normal <a href="https://conan.io/">conan</a> + <a href="https://cmake.org/">CMake</a> build process Essentially what's in make.sh</p>
<div class="fragment"><div class="line"># From project root</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">conan install .. # May add &quot;-s build_type=Release&quot;</div>
<div class="line">cmake -DCMAKE_BUILD_TYPE=Release .. # Or &quot;Debug&quot; or &quot;RelWithDebInfo&quot;</div>
<div class="line">cmake --build .</div>
<div class="line"># cmake --build . -t install # If installing</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1"></a>
Alternative usage</h2>
<p><a href="https://jfrog.com/artifactory/">jfrog artifactory</a> hosts conan packages for free</p>
<p>Add my repo with conan, calling it whatever you wish, then consume via conan as normal</p>
<div class="fragment"><div class="line">conan remote add arghnews_jfrog https://arghnews.jfrog.io/artifactory/api/conan/arghnews-conan</div>
</div><!-- fragment --><p>Then add to conanfile.txt or conanfile.py, in requires:</p>
<div class="fragment"><div class="line">wordsearch_solver/[&gt;=0.1.10]@arghnews/testing # Or whatever version, or version range</div>
</div><!-- fragment --><p>And build/use normally your project normally with conan</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Project structure</h1>
<ul>
<li><a class="el" href="namespacedictionary__std__vector.html">dictionary_std_vector</a></li>
</ul>
<p>Sorted vector of strings. Uses binary searches, so O(log(n)) where n is the number of strings for every operation.</p>
<hr  />
<ul>
<li><a class="el" href="namespacedictionary__std__set.html">dictionary_std_set</a></li>
</ul>
<p>Similar to a sorted vector, but std::set, so red-black tree implementation, with slightly worse performance than the vector, I suspect due to worse cache/memory spatial locality. Also O(log(n)) in number of words in dictionary performance.</p>
<hr  />
<ul>
<li><a class="el" href="namespacetrie.html">trie</a></li>
</ul>
<p>Recursive tree structure of nodes, where each node holds a vector-like container of edges, and each edge consists of a character and a pointer to the corresponding child node. To lookup a word of length "m", using a dictionary with "d" distinct characters, for example d == 26 for lowercase ascii and the English alphabet, lookup is O(m * d). Realistically, the factor of d will usually be much less than the actual value of d, so really more like just O(m). Could say that furthermore, since (in English at least) average word length is much shorter than max(m) anyway, essentially this becomes almost constant time lookup.</p>
<hr  />
<ul>
<li><a class="el" href="namespacecompact__trie.html">compact_trie</a></li>
</ul>
<p>Similar to the trie, but now everything's inline, and the whole thing is in one big contiguous memory block. NOTE: this (currently) only works for lowercase ascii. A node consists of a bitset of size 26 (bits), with each bit representing an edge to a child node and a letter. A node also has a bool to indicate whether it's a word end, and an int to indicate how many nodes before this one on the same row existed, which is required for calculating the offset in the next row of the child nodes. We also keep a track of indexes into said vector of nodes that correspond to each row. A row corresponds to all the letters at that position in a word. Lookup for a word of length "m" is similar to the trie, however now each lookup for every letter of a word, rather than a linear search through a small list of letters, is a lookup for a bit being on in a bitset. Then, assuming that letter is present, read off from the node the offset on the next row, where that letter's next node is found. Lookup for a word of length m is O(m), plus likely better cache locality (unless change trie to use a pool allocator, which should be very possible as can precompute size from input).</p>
<hr  />
<ul>
<li><a class="el" href="namespacecompact__trie2.html">compact_trie2</a></li>
</ul>
<p>In the <a class="el" href="namespacecompact__trie.html" title="namespace compact_trie">compact_trie</a>, every node is a fixed size (happens to be 16 bytes currently on my system x64 libstdc++8). There must be at least as many nodes as words, roughly ~115k in the (slightly altered) GNU English dictionary used for this. There may be more, if for example a node is required to represent child nodes, but is not a word itself.</p>
<p>For example, the prefix "abj" is not a word, but would need a node in the <a class="el" href="namespacecompact__trie.html" title="namespace compact_trie">compact_trie</a> trie, to allow it to link to other words that have "abj" as a prefix, such as "abject".</p>
<p>The idea with <a class="el" href="namespacecompact__trie2.html" title="namespace compact_trie2">compact_trie2</a> was to try and optimise this further, to allow for two types of node.</p>
<p>In this trie, there are empty nodes and full ones.</p><ul>
<li>Full nodes are like the nodes in any other trie, they can represent the end of a word, plus have links to child nodes.</li>
<li>Empty nodes are one byte, and represent only the end of a word.</li>
</ul>
<p>The hope was a tradeoff in saving space would offset the additional lookup complexity in this data structure. A complication that arises is the variable sizes of nodes, offset calcuation is more complex.</p>
<p>The idea with this trie was to have everything inline in one data structure. Unfortunately, performance tends to be only slightly better than the (pointer) trie, and worse than the <a class="el" href="namespacecompact__trie.html" title="namespace compact_trie">compact_trie</a>. It has to do more work at each node to calculate the offset to the next one.</p>
<div class="fragment"><div class="line">Example layout for a node that has two children</div>
<div class="line">Node size is byte at A (size) * 3 + 2.</div>
<div class="line">|____| = 1 byte</div>
<div class="line"> </div>
<div class="line">                        &#39;a&#39;   &#39;c&#39;</div>
<div class="line">|____||____||____||____||____||____||____||____||____||____|</div>
<div class="line"> A     B     C     DE    F     G     H     H     I     I    </div>
<div class="line"> </div>
<div class="line">- A: 1 byte, size, number of characters in this node</div>
<div class="line">- B, C, D: Bytes B and C plus all but the highest bit in D make up the offset,</div>
<div class="line">    from the start of the next row, where this node&#39;s children begin.</div>
<div class="line">- E: Highest bit in byte D. Flag to signal whether this node represents</div>
<div class="line">    the end of a word</div>
<div class="line">- F, G: Sorted 1 byte entries of child nodes.</div>
<div class="line">    Ie. F may be the ascii corresponding to &#39;a&#39;, G == &#39;c&#39;</div>
<div class="line">- H, I: Corresponding child intra-node offsets, from the next row node offset</div>
<div class="line">    given by BCD (with highest bit zeroed).</div>
<div class="line">Ie. to find the child node from the example node for the letter &#39;c&#39;, get the</div>
<div class="line">    position of the start of the next row,</div>
<div class="line">    add BCD (without highest bit) and add the letter offset in the 2 byte int I.</div>
</div><!-- fragment --><hr  />
<ul>
<li><a class="el" href="dir_44cec6e3ea30e076b9313c4641539d9f.html">benchmark</a></li>
</ul>
<p>Google benchmark the time to solve a wordsearch</p>
<p>My benchmark I use, in bench.sh</p>
<p>Uses the dictionary file that is ~115k lines, and a 100x100 wordsearch, measures the time to solve it</p>
<p>This benchmark was run using clang 12, libstdc++8 and an SSD (Crucial MX500). LTO was used. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Benchmark   </th><th class="markdownTableHeadNone">Time   </th><th class="markdownTableHeadNone">CPU   </th><th class="markdownTableHeadNone">Iterations    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bench_long_words/trie::Trie   </td><td class="markdownTableBodyNone">109 ms   </td><td class="markdownTableBodyNone">109 ms   </td><td class="markdownTableBodyNone">6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bench_long_words/compact_trie::CompactTrie   </td><td class="markdownTableBodyNone">74.3 ms   </td><td class="markdownTableBodyNone">74.3 ms   </td><td class="markdownTableBodyNone">9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bench_long_words/compact_trie2::CompactTrie2   </td><td class="markdownTableBodyNone">92.1 ms   </td><td class="markdownTableBodyNone">92.1 ms   </td><td class="markdownTableBodyNone">8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bench_long_words/dictionary_std_vector::DictionaryStdVector   </td><td class="markdownTableBodyNone">330 ms   </td><td class="markdownTableBodyNone">330 ms   </td><td class="markdownTableBodyNone">2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bench_long_words/dictionary_std_set::DictionaryStdSet   </td><td class="markdownTableBodyNone">601 ms   </td><td class="markdownTableBodyNone">601 ms   </td><td class="markdownTableBodyNone">1   </td></tr>
</table>
<p>Some points to take away:</p><ul>
<li>Unsurprising that the dictionary_std_vector/dictionary_std_set solvers are slowest. They simple use sorted std containers, so their furhter functions will return true too often (as they can't do better) and both their contains and further functions are O(log(n)) where n is the size of the dictionary.</li>
</ul>
<p>When run with gcc8 instead of clang12, see much worse performance for the compact tries.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Benchmark   </th><th class="markdownTableHeadNone">Time   </th><th class="markdownTableHeadNone">CPU   </th><th class="markdownTableHeadNone">Iterations    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bench_long_words/trie::Trie   </td><td class="markdownTableBodyNone">109 ms   </td><td class="markdownTableBodyNone">109 ms   </td><td class="markdownTableBodyNone">6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bench_long_words/compact_trie::CompactTrie   </td><td class="markdownTableBodyNone">127 ms   </td><td class="markdownTableBodyNone">127 ms   </td><td class="markdownTableBodyNone">6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bench_long_words/compact_trie2::CompactTrie2   </td><td class="markdownTableBodyNone">103 ms   </td><td class="markdownTableBodyNone">103 ms   </td><td class="markdownTableBodyNone">7    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bench_long_words/dictionary_std_vector::DictionaryStdVector   </td><td class="markdownTableBodyNone">360 ms   </td><td class="markdownTableBodyNone">360 ms   </td><td class="markdownTableBodyNone">2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bench_long_words/dictionary_std_set::DictionaryStdSet   </td><td class="markdownTableBodyNone">689 ms   </td><td class="markdownTableBodyNone">689 ms   </td><td class="markdownTableBodyNone">1   </td></tr>
</table>
<hr  />
<ul>
<li><a class="el" href="dir_e73efb7fefbc7e62e9245f1e6f68c63a.html">cmdline_app</a></li>
</ul>
<p>Cmdline app used for profiling time taken to solve a wordsearch using a particular solver and dictionary. Uses my slightly modified gperftools profiler.</p>
<hr  />
<ul>
<li>gui_app</li>
</ul>
<p>Simple wordsearch gui using ImGui as backend. </p><dl class="section note"><dt>Note</dt><dd>Whilst this is a subdirectory, it's built as an entirely standalone project, that pulls this (wordsearch_solver) project via conan.</dd></dl>
<hr  />
<ul>
<li><a class="el" href="namespacesolver.html">solver</a></li>
</ul>
<p>Contains the algorithm to actually solver a wordsearch. Exposes types that clients should use to consume this library.</p>
<hr  />
<ul>
<li><a class="el" href="namespaceutility.html">utility</a></li>
</ul>
<hr  />
<ul>
<li>cmake</li>
</ul>
<hr  />
<ul>
<li><a class="el" href="dir_13e138d54eb8818da29c3992edef070a.html">test</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
