<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wordsearch Solver: trie::Trie Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wordsearch Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetrie.html">trie</a></li><li class="navelem"><a class="el" href="classtrie_1_1Trie.html">Trie</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtrie_1_1Trie-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">trie::Trie Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Recursive immutable node based trie.  
 <a href="classtrie_1_1Trie.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="trie_8hpp_source.html">trie.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5c788fe089e4865eda5d889e9e90c0c0"><td class="memItemLeft" align="right" valign="top"><a id="a5c788fe089e4865eda5d889e9e90c0c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> (<a class="el" href="classtrie_1_1Trie.html">Trie</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a5c788fe089e4865eda5d889e9e90c0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2121a16cc7656d6400948239b0830b11"><td class="memItemLeft" align="right" valign="top"><a id="a2121a16cc7656d6400948239b0830b11"></a>
<a class="el" href="classtrie_1_1Trie.html">Trie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classtrie_1_1Trie.html">Trie</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a2121a16cc7656d6400948239b0830b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9085e9de973c7e7518b87313b68bd433"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrie_1_1Trie.html#a9085e9de973c7e7518b87313b68bd433">Trie</a> (const <a class="el" href="classtrie_1_1Trie.html">Trie</a> &amp;)=delete</td></tr>
<tr class="separator:a9085e9de973c7e7518b87313b68bd433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1047bddb9ee4b3ea37c8bd4fb91b5c0"><td class="memItemLeft" align="right" valign="top"><a id="aa1047bddb9ee4b3ea37c8bd4fb91b5c0"></a>
<a class="el" href="classtrie_1_1Trie.html">Trie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classtrie_1_1Trie.html">Trie</a> &amp;)=delete</td></tr>
<tr class="separator:aa1047bddb9ee4b3ea37c8bd4fb91b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6294d4e96c5136be6ae263e07ebbae"><td class="memItemLeft" align="right" valign="top"><a id="a7a6294d4e96c5136be6ae263e07ebbae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> (const std::initializer_list&lt; std::string_view &gt; &amp;words)</td></tr>
<tr class="separator:a7a6294d4e96c5136be6ae263e07ebbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2b10c6b70fbef583bd91174a01ff3f"><td class="memItemLeft" align="right" valign="top"><a id="aef2b10c6b70fbef583bd91174a01ff3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> (const std::initializer_list&lt; std::string &gt; &amp;words)</td></tr>
<tr class="separator:aef2b10c6b70fbef583bd91174a01ff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594d160b9f62e42e104369f33df06f42"><td class="memItemLeft" align="right" valign="top"><a id="a594d160b9f62e42e104369f33df06f42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> (const std::initializer_list&lt; const char * &gt; &amp;words)</td></tr>
<tr class="separator:a594d160b9f62e42e104369f33df06f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83528a79056925db3107fed47a528b53"><td class="memTemplParams" colspan="2"><a id="a83528a79056925db3107fed47a528b53"></a>
template&lt;class Iterator1 , class Iterator2 &gt; </td></tr>
<tr class="memitem:a83528a79056925db3107fed47a528b53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Trie</b> (Iterator1 first, const Iterator2 last)</td></tr>
<tr class="separator:a83528a79056925db3107fed47a528b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a75d2260810e62be36cd05fd5551a51"><td class="memTemplParams" colspan="2"><a id="a3a75d2260810e62be36cd05fd5551a51"></a>
template&lt;class Strings &gt; </td></tr>
<tr class="memitem:a3a75d2260810e62be36cd05fd5551a51"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtrie_1_1Trie.html#a3a75d2260810e62be36cd05fd5551a51">Trie</a> (Strings &amp;&amp;strings_in)</td></tr>
<tr class="memdesc:a3a75d2260810e62be36cd05fd5551a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor that actually does the work. <br /></td></tr>
<tr class="separator:a3a75d2260810e62be36cd05fd5551a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad733a744ce6fc453926a017b05f85a2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrie_1_1Trie.html#ad733a744ce6fc453926a017b05f85a2c">contains</a> (std::string_view word) const</td></tr>
<tr class="memdesc:ad733a744ce6fc453926a017b05f85a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this dictionary contains <code>word</code>.  <a href="classtrie_1_1Trie.html#ad733a744ce6fc453926a017b05f85a2c">More...</a><br /></td></tr>
<tr class="separator:ad733a744ce6fc453926a017b05f85a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023bc5ca03feaa402cc9777897327320"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrie_1_1Trie.html#a023bc5ca03feaa402cc9777897327320">further</a> (std::string_view word) const</td></tr>
<tr class="memdesc:a023bc5ca03feaa402cc9777897327320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this dictionary <b>might</b> contain words with <code>word</code> as a prefix.  <a href="classtrie_1_1Trie.html#a023bc5ca03feaa402cc9777897327320">More...</a><br /></td></tr>
<tr class="separator:a023bc5ca03feaa402cc9777897327320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b19281a1648b36164405fbab1586dcb"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a1b19281a1648b36164405fbab1586dcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtrie_1_1Trie.html#a1b19281a1648b36164405fbab1586dcb">contains_further</a> (const std::string_view stem, const std::string_view suffixes, OutputIterator contains_further_it) const</td></tr>
<tr class="memdesc:a1b19281a1648b36164405fbab1586dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each char in suffix appended to stem, check whether this dictionary contains this word and if it may contain longer words with this prefix.  <a href="classtrie_1_1Trie.html#a1b19281a1648b36164405fbab1586dcb">More...</a><br /></td></tr>
<tr class="separator:a1b19281a1648b36164405fbab1586dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1515cdfe09abc807302437d89804725d"><td class="memItemLeft" align="right" valign="top"><a id="a1515cdfe09abc807302437d89804725d"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a1515cdfe09abc807302437d89804725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddfac163db0bd1bf28db400545c0a1e"><td class="memItemLeft" align="right" valign="top"><a id="aaddfac163db0bd1bf28db400545c0a1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:aaddfac163db0bd1bf28db400545c0a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aabf06ad08c9c96c78a3f84ca80870dc3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtrie_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrie_1_1Trie.html#aabf06ad08c9c96c78a3f84ca80870dc3">search</a> (std::string_view word) const</td></tr>
<tr class="separator:aabf06ad08c9c96c78a3f84ca80870dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa922dc0e0e873054ce5089e4d2aa6ff3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtrie_1_1Node.html">Node</a> *, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrie_1_1Trie.html#aa922dc0e0e873054ce5089e4d2aa6ff3">insert</a> (std::string_view word)</td></tr>
<tr class="separator:aa922dc0e0e873054ce5089e4d2aa6ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac478fe5da46436f35fd2f1ce23d3ae44"><td class="memItemLeft" align="right" valign="top"><a id="ac478fe5da46436f35fd2f1ce23d3ae44"></a>
<a class="el" href="classtrie_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_</b></td></tr>
<tr class="separator:ac478fe5da46436f35fd2f1ce23d3ae44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bf655c53fee0b40e0cfd85b9f839cb"><td class="memItemLeft" align="right" valign="top"><a id="af9bf655c53fee0b40e0cfd85b9f839cb"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_</b></td></tr>
<tr class="separator:af9bf655c53fee0b40e0cfd85b9f839cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49d13b08020454c7982559169ae1c8"><td class="memItemLeft" align="right" valign="top"><a id="a7a49d13b08020454c7982559169ae1c8"></a>
<a class="el" href="classutility_1_1FlatCharValueMap.html">utility::FlatCharValueMap</a>&lt; const <a class="el" href="classtrie_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cache_</b></td></tr>
<tr class="separator:a7a49d13b08020454c7982559169ae1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac7afe31f8b096e614adc218f5048287b"><td class="memItemLeft" align="right" valign="top"><a id="ac7afe31f8b096e614adc218f5048287b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classtrie_1_1Trie.html">Trie</a> &amp;ct)</td></tr>
<tr class="separator:ac7afe31f8b096e614adc218f5048287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Recursive immutable node based trie. </p>
<p>Recursive tree structure of nodes, where each node holds a vector-like container of edges, and each edge consists of a character and a pointer to the corresponding child node. To lookup a word of length "m", using a dictionary with "d" distinct characters, for example d == 26 for lowercase ascii and the English alphabet, lookup is O(m * d).</p>
<p>Realistically, the factor of d will usually be much less than the actual value of d, so really more like just O(m). Could say that furthermore, since (in English at least) average word length is much shorter than max(m) anyway, essentially this becomes almost constant time lookup.</p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe even for just reading, due to use of unprotected internal cache. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9085e9de973c7e7518b87313b68bd433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9085e9de973c7e7518b87313b68bd433">&#9670;&nbsp;</a></span>Trie()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">trie::Trie::Trie </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrie_1_1Trie.html">Trie</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="trie_2include_2wordsearch__solver_2trie_2node_8hpp_source.html">trie/include/wordsearch_solver/trie/node.hpp</a> before changing/implementing this, must implement proper deep copy, traits don't behave nicely. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad733a744ce6fc453926a017b05f85a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad733a744ce6fc453926a017b05f85a2c">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trie::Trie::contains </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this dictionary contains <code>word</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>The word to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>word</code> is present, else <code>false</code> </dd></dl>

</div>
</div>
<a id="a1b19281a1648b36164405fbab1586dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b19281a1648b36164405fbab1586dcb">&#9670;&nbsp;</a></span>contains_further()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void trie::Trie::contains_further </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>stem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>suffixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>contains_further_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each char in suffix appended to stem, check whether this dictionary contains this word and if it may contain longer words with this prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stem</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffixes</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contains_further_it</td><td>This function is what the solver algorithm calls every iteration to ask the dictionary solver implementation to do its work.</td></tr>
  </table>
  </dd>
</dl>
<p><code>contains_further_it</code> should be assigned to and incremented like an output iterator. The value written should be a std::pair&lt;bool, bool&gt;.</p>
<p>Example contains_further implementation: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* node = this-&gt;<a class="code" href="classtrie_1_1Trie.html#aabf06ad08c9c96c78a3f84ca80870dc3">search</a>(stem);</div>
<div class="line"><span class="keywordflow">if</span> (!node) {</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> [i, c] : ranges::views::enumerate(suffixes)) {</div>
<div class="line">  <span class="keyword">const</span> std::string_view suffix = {&amp;c, 1};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="classtrie_1_1Trie.html#ad733a744ce6fc453926a017b05f85a2c">contains</a> = detail::contains(*node, suffix);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="classtrie_1_1Trie.html#a023bc5ca03feaa402cc9777897327320">further</a> = detail::further(*node, suffix);</div>
<div class="line">  *contains_further_it++ = {<a class="code" href="classtrie_1_1Trie.html#ad733a744ce6fc453926a017b05f85a2c">contains</a>, <a class="code" href="classtrie_1_1Trie.html#a023bc5ca03feaa402cc9777897327320">further</a>};</div>
<div class="line">}</div>
<div class="ttc" id="aclasstrie_1_1Trie_html_a023bc5ca03feaa402cc9777897327320"><div class="ttname"><a href="classtrie_1_1Trie.html#a023bc5ca03feaa402cc9777897327320">trie::Trie::further</a></div><div class="ttdeci">bool further(std::string_view word) const</div><div class="ttdoc">Check if this dictionary might contain words with word as a prefix.</div><div class="ttdef"><b>Definition:</b> trie.cpp:49</div></div>
<div class="ttc" id="aclasstrie_1_1Trie_html_aabf06ad08c9c96c78a3f84ca80870dc3"><div class="ttname"><a href="classtrie_1_1Trie.html#aabf06ad08c9c96c78a3f84ca80870dc3">trie::Trie::search</a></div><div class="ttdeci">const Node * search(std::string_view word) const</div><div class="ttdef"><b>Definition:</b> trie.cpp:80</div></div>
<div class="ttc" id="aclasstrie_1_1Trie_html_ad733a744ce6fc453926a017b05f85a2c"><div class="ttname"><a href="classtrie_1_1Trie.html#ad733a744ce6fc453926a017b05f85a2c">trie::Trie::contains</a></div><div class="ttdeci">bool contains(std::string_view word) const</div><div class="ttdoc">Check if this dictionary contains word.</div><div class="ttdef"><b>Definition:</b> trie.cpp:45</div></div>
</div><!-- fragment --><p>Each character's position in <code>suffix</code> corresponds to the order that that <code>suffix's</code> output should be written to <code>contains_further_it</code>.</p>
<p><code>suffixes</code> is <b>not</b> guaranteed to be sorted. </p>

</div>
</div>
<a id="a023bc5ca03feaa402cc9777897327320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023bc5ca03feaa402cc9777897327320">&#9670;&nbsp;</a></span>further()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trie::Trie::further </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this dictionary <b>might</b> contain words with <code>word</code> as a prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>The prefix to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if there are no more strings in the dictionary with <code>word</code> as a prefix, <code>true</code> if there might be.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some solvers do not conclusively know whether, for a prefix <code>word</code>, there are more words that contain that prefix. This is acceptable, though sub-optimal and will result in wasted search time, as long as eventually this returns false, assuming for <code>word</code> there are in fact no more words with that prefix. </dd></dl>

</div>
</div>
<a id="aa922dc0e0e873054ce5089e4d2aa6ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa922dc0e0e873054ce5089e4d2aa6ff3">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtrie_1_1Node.html">Node</a> *, bool &gt; trie::Trie::insert </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> of a pointer to the node corresponding to the end of the word, and a bool indicating whether or not insertion was successful (<code>false</code> if the word was already present). </dd></dl>

</div>
</div>
<a id="aabf06ad08c9c96c78a3f84ca80870dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf06ad08c9c96c78a3f84ca80870dc3">&#9670;&nbsp;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtrie_1_1Node.html">Node</a> * trie::Trie::search </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>Node*</code> to the node corresponding to the end of the word if found, else <code>nullptr</code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>trie/include/wordsearch_solver/trie/<a class="el" href="trie_8hpp_source.html">trie.hpp</a></li>
<li>trie/include/wordsearch_solver/trie/trie.tpp</li>
<li>trie/src/trie.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
